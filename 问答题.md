#### TASK1

1. byte short int long float double char boolean

2. byte  一个字节 -128~127

   short 两个字节 -2^15~2^15-1

   int 四个字节  -2^31~2^31-1

   long 八个字节 -2^63~2^63-1

​	小范围的类型与大范围的类型运算时，会自动	转成大范围的类型。Java中基本数据类型的范	围从小到大依次是：byte、short、char、	int、long、float、double。所以int和long运	算时结果是long。

​	强制类型转换：大范围类型向小范围类型转换	时，需要在数据前加括号，写上要转换到的类	型。如 double b1=3.1415;  int a = (int) b1;同	时数据会丢失一点。如果范围溢出，得到的结	果是一个负数。

3. ```java
   int a=4
   char c='0';
   int b=a+c;
   ```

   涉及自动类型转换，因为int的范围大于char。b的值是52.因为在运算时c自动转成int类型，‘0’对应的ASCII码是48，因此b = 4+48=52

4. 包装类是将基本数据类型封装成对象的形式，以便能够使用对象的方法。

​	引用类型相当于指向函数或者对象的指针

​	基本数据类型缓存池，对于某些小的整数值	通常是-128到127，Integer`、`Short、Byte	和Character等包装类会缓存其对象。当使用	valueOf方法来创建这些范围内的整数值的包	装类对象时，会得到缓存中的对象引用，而	不是新创建的对象。

​	第一个输出：false

​		通过new在堆区中开辟两个空间，分别	创建两个Integer对象，并将他们的引用分别	传给x,y，所以x和y的引用不相同，x==y 比	较的是两个对象的引用，所以是false

​	第二个输出：true

​		通过valueOf方法创建的Integer对象，	且在缓存范围内，该方法会将返回缓存中的	同一个对象，因此z,k接受到了同一个引用，	结果为true

​	第三个输出：false

​		300超出了缓存的范围，因此valueOf方	法为每个调用创建了新的对象，因此m,p接	收到的引用不同，所以结果的false

#### TASK2

5. ++a是前置递增，所以a先自己+1变为6再进行加法运算，b++是后置递增，b先进行加法运算，再将自己+1，所以c=6+7=13，b变为8，所以输出为：13

   ​			     6 8

6. 形式为0010

   对于任意的非负整数a，式子a&(-a)表示从右往左第一个出现1的位置所表示的数。

   先将a取反 1101

   再+1得到补码-a 1110

   再进行&运算得到  0010

   简单证明：第一次出现的1的位置（记作标志位）右边的零会在取反的时候全部变成1，标志位上的1变成0，标志位左边的数都取反，随后在加一的时候那些全部变成的1会不断进位再次变成0，直到遇到标志位上的0接受上一位的进位变成1，进行&运算时因为标志位左边全部取反了，所以&之后全部为0，标志位上1&1=1，标志位右边0&0=0，所以最后只会有标志位上一个1,其余全是0.

7.  float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。

   在IEEE 754规定中，一个浮点数表示为V = (-1)^s * M * 2^E   s是符号0为正，1为负，M表示有效数字在[1,2)之间，E是指数位.

   float存储的时候有1位符号位，8位指数位，23位尾数位。所以指数位数为

   11111110=254时（因为11111111有特殊用途），尾数位为11111111111111111111111=8,388,607时最大，代入前面的公式得到。

   double有一位符号位，11位指数位，52位尾数位置，计算方法同理：

8. Java在内存中有一个区域叫字符串常量池，存储字符串本身。而且String不可变，创建之后内容就不可以改变，对String操作时都会创建一个新的对象。String的数据类型是引用类型。

   代码解释：

   ```java
   public class Test {  
      
       public static void main(String[] args) {  
           Test t1 = new Test();  
           String s = "hello"; 
           //创建一个String对象，s存的是hello在字符串常量池中
           //的地址。
           t1.append(s); 
           //因为在append方法中对s进行了修改，创建了新的对象，
           //对原来的实参s没有改变，所以还是输出了hello
           System.out.println("main: " + s);  
       }  
      
       private void append(String s) {  //通过引用传递传入s
           s += " world";  //对s进行了增加字符串的操作，
           //此时已经创建了一个新的String对象，将引用保存到形参s，
         	//此时s为hello world，所以就输出hello world
           System.out.println("method: " + s);  
       }  
   }

